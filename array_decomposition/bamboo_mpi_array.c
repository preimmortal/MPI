//This code was generated by Bamboo. The corresponding MPI input code might be developed by different authors
//Contact infomation:
//Nguyen Thanh Nhat Tan
//Email: nnguyent@ucsd.edu
//Website:
//http://bamboo.ucsd.edu
//Add Tarragon headers
#include <mpi.h>
//#ifdef __cplusplus
#include "tgn_types.h"
#include <sys/time.h> 
#include <stdlib.h> 
#include "system/locks.h"
#include "task.h"
#include "message.h"
#include "tarragon.h"
#include "graph.h"
#include "opExec.h"
#include "maps/cartesian_map.h"
#include "visitors/limiter.h"
#include "visitors/sizer.h"
#include "visitors/affinity.h"
#include <list>
#define TARRAGON_SYSTEM_BUFFER_SIZE TGN_BUF_SIZE
#if _OPENMP
#include <omp.h>
#define BAMBOO_COPY_CHUNKSIZE 1024
#endif
#include "visitors/connectors.h"
using namespace tgn;
using namespace std;
/*int getsizeof(MPI_Datatype mpiType){ 
  switch(mpiType){ 
     case MPI_DOUBLE: return sizeof(double); 
     case MPI_FLOAT: return sizeof(float); 
     case MPI_INT: return sizeof(int); 
     case MPI_CHAR: return sizeof(char); 
     case MPI_SHORT: return sizeof(short); 
     case MPI_BYTE: return sizeof(char); 
     case MPI_LONG: return sizeof(long); 
     case MPI_UNSIGNED_CHAR: return sizeof(unsigned char); 
     case MPI_UNSIGNED_SHORT: return sizeof(unsigned short); 
     case MPI_UNSIGNED_LONG: return sizeof(unsigned long); 
     case MPI_UNSIGNED: return sizeof(unsigned); 
     case MPI_LONG_DOUBLE: return sizeof(long double); 
     //will add more 
 } 
}*/ 
void Bamboo_OpExec(void *a, void *b, int count, MPI_Datatype datatype, MPI_Op op);
#define BAMBOO_EXIST_COMM(cond) __if_exists(cond)
/******************************************************************************
* FILE: mpi_array.c
* DESCRIPTION: 
*   MPI Example - Array Assignment - C Version
*   This program demonstrates a simple data decomposition. The master task
*   first initializes an array and then distributes an equal portion that
*   array to the other tasks. After the other tasks receive their portion
*   of the array, they perform an addition operation to each array element.
*   They also maintain a sum for their portion of the array. The master task 
*   does likewise with its portion of the array. As each of the non-master
*   tasks finish, they send their updated portion of the array to the master.
*   An MPI collective communication call is used to collect the sums 
*   maintained by each task.  Finally, the master task displays selected 
*   parts of the final array and the global sum of all array elements. 
*   NOTE: the number of MPI tasks must be evenly divided by 4.
* AUTHOR: Blaise Barney
* LAST REVISED: 04/13/05
****************************************************************************/
#include "mpi.h"
#include <stdio.h>
#include <stdlib.h>
#define  ARRAYSIZE	16000000
#define  MASTER		0
float data[16000000UL];

class _BAMBOOGeneratedTask : public MappedTask < 1 >
{
  public: static int argc;
  static char **argv;
  int _tarragon_loop_executing;
  int _tarragonCommHandle;
  static bool _tpriority;
  static bool _taffinity;
  static unsigned int _aggregation;
  int _tarragonProcessId;
  int _tarragonTaskId;
  static int _tarragonCommunicatorSize;
  static int _tarragonP0;
  int _tarragonSourceKey;
  int _tarragonTagKey;
  int _tarragonMessageSize;
  int _tarragonMessageDestination;
  int _tarragonMessageSource;
  int storedMessageDirection;
  int _tarragonNoOfReceives;
  int _tarragonIsMessageReceived;
  int _tarragonNoMessageRepeat;
  int _tarragonReceiveTypeSize;
  const MPI_Status* _BAMBOO_Status;
  Message* tempMessage;
  map<const MPI_Status*, int> _BAMBOO_MessageSizeMap;
  map<int, int*> _BAMBOOCommMap;
  map<string, int> commColorList;
  map<string, int> commKeyList;
  map<int, list<Message*>*>::iterator tempListMessage;
  int sendBarrierBufferInternal;
  int recvBarrierBufferInternal;
  map<int, list<Message*>*>::iterator tempReuseMessageList;
  int _bambooTotalMemoryReuse;
  map<int, map<int, list<Message*>*> >::iterator tempMapMessage;
  map<int, map<int, list<Message*>*> > _tarragonReceiveMessageMap;
  map<int, list<Message*>*> _tarragonReuseMessageList;
  map<int, list<Message*>*>::iterator _tarragonReceiveMessageList;
  bool _tarragonIsFirstTimeRunning0;
  bool _tarragonIsFirstTimeRunning1;
  bool _tarragonIsFirstTimeRunning2;
  bool _tarragonIsFirstTimeRunning3;
  bool _tarragon_loop_initializing;
  bool _tarragon_fireable;
  bool _tarragonIsInitSend;
  int _tarragonIterationRollBack0;
  int _tarragonIterationCurrent0;
  int _tarragonIterationRollBack1;
  int _tarragonIterationCurrent1;
  int _tarragonIterationRollBack2;
  int _tarragonIterationCurrent2;
  int _tarragonIterationRollBack3;
  int _tarragonIterationCurrent3;
  int _tarragonIterationRollBack4;
  int _tarragonIterationCurrent4;
  int _tarragonIterationRollBack5;
  int _tarragonIterationCurrent5;
  int _tarragonIterationRollBack6;
  int _tarragonIterationCurrent6;
  int _tarragonIterationRollBack7;
  int _tarragonIterationCurrent7;
  int _tarragonIterationRollBack8;
  int _tarragonIterationCurrent8;
  int _tarragonIterationRollBack9;
  int _tarragonIterationCurrent9;
  int _tarragonIterationRollBack10;
  int _tarragonIterationCurrent10;
  int _tarragonIterationRollBack11;
  int _tarragonIterationCurrent11;
  

  virtual ~_BAMBOOGeneratedTask() throw()
{
  }
  std::list<OutDependency*> _tarragonNeighborList;
  OutDependency* _tarragonNeighbor;
  std::map<int, Message*> _tarragonSendMessageList;
  Message* _tarragonMessage;
  MPI_Comm comm__17;
  int root__16;
  MPI_Op op__15;
  MPI_Datatype datatype__14;
  int count__13;
  void *recvbuf__12;
  const void *sendbuf__11;
  char *tempbuf;
  int _bambooCommSize;
  int _bambooMyRank;
  MPI_Comm comm__8;
  int root__7;
  MPI_Op op__6;
  MPI_Datatype datatype__5;
  int count__4;
  void *recvbuf__3;
  const void *sendbuf__2;
  MPI_Status status;
/***** Initializations *****/
  float sum;
  float mysum;
  int chunksize;
  int source;
  int tag2;
  int tag1;
  int j;
  int i;
  int offset;
  int dest;
  int rc;
  int taskid;
  int numtasks;
}
;

class OlapClass2 : virtual public _BAMBOOGeneratedTask
{
  

  public: void initializeOlapRegion()
{
  }
  

  void executeOlapRegion()
{
  }
  

  void injectOlapRegion2()
{
  }
}
;

class OlapClass3 : public OlapClass2
{
  

  public: void initializeOlapRegion3()
{
    isExitOlapRegion3= false;
    _tarragonIsFirstTimeRunning3= 1;
    mask = 0x1;
    if (mask < _bambooCommSize) {
      if (!((mask & (((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize)) == 0)) {
        _tarragonMessageSize = count__13 * getsizeof(datatype__14);
        tempReuseMessageList = _tarragonReuseMessageList.find(TARRAGON_SYSTEM_BUFFER_SIZE);
        if (tempReuseMessageList != _tarragonReuseMessageList.end()) 
          if (!((*tempReuseMessageList).second)->empty()) {
            _tarragonMessage = ((*tempReuseMessageList).second)->front();
            ((*tempReuseMessageList).second)->pop_front();
            _tarragonMessage->set_size(_tarragonMessageSize+sizeof(Message));
          }
          else {
            if (_tarragonMessageSize > TARRAGON_SYSTEM_BUFFER_SIZE) {
              _attributes._state = T_ERROR;
              printf("Task %d is about to send a message that is larger than the system buffer -> Tarragon aborts all computation. Please increase the system buffer size, compile and run the code again.\n", _id);
              goto _tarragonExecuteExitOlap;
            }
            _tarragonMessage = make_message<BufferedMessage>(_tarragonMessageSize);
          }
        else {
          if (_tarragonMessageSize > TARRAGON_SYSTEM_BUFFER_SIZE) {
            _attributes._state = T_ERROR;
            printf("Task %d is about to send a message that is larger than the system buffer -> Tarragon aborts all computation. Please increase the system buffer size, compile and run the code again.\n", _id);
            goto _tarragonExecuteExitOlap;
          }
          _tarragonReuseMessageList.insert(pair<int, list<Message*>* > (TARRAGON_SYSTEM_BUFFER_SIZE, new list<Message*>));
          _tarragonMessage = make_message<BufferedMessage>(_tarragonMessageSize);
        }
{
          #if _OPENMP
;
          
#pragma omp parallel
{
            int numChunks = 1;
            if (_tarragonMessageSize % BAMBOO_COPY_CHUNKSIZE == 0) 
              numChunks = _tarragonMessageSize / BAMBOO_COPY_CHUNKSIZE;
            else 
              numChunks = _tarragonMessageSize / BAMBOO_COPY_CHUNKSIZE + 1;
            
#pragma omp for
            for (int _bambooChunkIter = 0; _bambooChunkIter < numChunks; ++_bambooChunkIter) 
              memcpy(((char *)_tarragonMessage->payload<void>()) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,((char *)recvbuf__12) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,_bambooChunkIter<(numChunks-1)?BAMBOO_COPY_CHUNKSIZE:(_tarragonMessageSize-(numChunks-1)*BAMBOO_COPY_CHUNKSIZE));
          }
          #else
;
          int _bambooPackPosition=0;
          Bamboo_Pack(recvbuf__12,count__13,datatype__14,_tarragonMessage->payload<void>(),_tarragonMessageSize,&_bambooPackPosition,MPI_COMM_WORLD);
          #endif
;
        }
        _tarragonMessage->set_src(_tarragonTaskId);
        *_tarragonMessage->key<int>() = 11100001;
        _tarragonMessageDestination = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) & ~mask) + root__16) % _bambooCommSize);
        _tarragonMessageDestination = comm__17== MPI_COMM_WORLD?_tarragonMessageDestination:_BAMBOOCommMap[comm__17][_tarragonMessageDestination+2];
        _tarragonNeighbor = dependency_out(_tarragonMessageDestination);
        _tarragonNeighbor->put(_tarragonMessage);
      }
    }
    if (mask < _bambooCommSize) {{
        if ((mask & (((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize)) == 0) {
          if (((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) < _bambooCommSize) {{
              _tarragonMessageSource = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) + root__16) % _bambooCommSize);
              _tarragonMessageSource = comm__17== MPI_COMM_WORLD?_tarragonMessageSource:_BAMBOOCommMap[comm__17][_tarragonMessageSource+2];
              tempMapMessage = _tarragonReceiveMessageMap.find(_tarragonMessageSource);
              if (tempMapMessage != _tarragonReceiveMessageMap.end()) {
                tempListMessage = ((*tempMapMessage).second).find(11100001);
                if (tempListMessage != ((*tempMapMessage).second).end()) 
                  if (((*tempListMessage).second)->empty()) {
                    _tarragon_fireable = false;
                  } else {}
                else {
                  _tarragon_fireable = false;
                  _tarragonSourceKey = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) + root__16) % _bambooCommSize);
                  _tarragonTagKey = 11100001;
                  _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
                }
              }
              else {
                _tarragon_fireable = false;
                _tarragonSourceKey = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) + root__16) % _bambooCommSize);
                _tarragonTagKey = 11100001;
                _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
              }
            }
          }
        }
      }
    }
    _tarragonExecuteExitOlap:;
  }
  bool isExitOlapRegion3;
  

  void executeOlapRegion3()
{
    if (mask < _bambooCommSize) {
      
#pragma bamboo receive
{
        if ((mask & (((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize)) == 0) {
          if (((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) < _bambooCommSize) {
            _tarragonMessageSource = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) + root__16) % _bambooCommSize);
            _tarragonMessageSource = comm__17== MPI_COMM_WORLD?_tarragonMessageSource:_BAMBOOCommMap[comm__17][_tarragonMessageSource+2];
{
              tempMapMessage = _tarragonReceiveMessageMap.find(_tarragonMessageSource);
              tempListMessage = ((*tempMapMessage).second).find(11100001);
{
                tempMessage = ((*tempListMessage).second)->front();
                ((*tempListMessage).second)->pop_front();
{
                  MPI_Type_size(datatype__14,&_tarragonReceiveTypeSize);
                  #if _OPENMP
;
                  
#pragma omp parallel
{
                    int _bambooReceiveMessageSize = tempMessage->size()-sizeof(Message);
                    int numChunks = 1;
                    if ((tempMessage->size()-sizeof(Message))/BAMBOO_COPY_CHUNKSIZE==0) 
                      numChunks= (tempMessage->size()-sizeof(Message))/BAMBOO_COPY_CHUNKSIZE;
                    else 
                      numChunks= (tempMessage->size()-sizeof(Message))/BAMBOO_COPY_CHUNKSIZE + 1;
                    
#pragma omp for
                    for (int _bambooChunkIter = 0; _bambooChunkIter < numChunks; ++_bambooChunkIter) 
                      memcpy(((char *)((void *)tempbuf)) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,((char *)tempMessage->payload<void>()) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,_bambooChunkIter<(numChunks-1)?BAMBOO_COPY_CHUNKSIZE:(_bambooReceiveMessageSize-(numChunks-1)*BAMBOO_COPY_CHUNKSIZE));
                  }
                  #else
;
                  int _bambooReceiveMessageSize = tempMessage->size()-sizeof(Message);
                  int _bambooUnpackPosition=0;
                  Bamboo_Unpack(tempMessage->payload<void>(),_bambooReceiveMessageSize,&_bambooUnpackPosition,((void *)tempbuf),_bambooReceiveMessageSize / _tarragonReceiveTypeSize,datatype__14,MPI_COMM_WORLD);
                  #endif
;
                  _BAMBOO_Status = ((MPI_Status *)((MPI_Status *)1));
                  _BAMBOO_MessageSizeMap[_BAMBOO_Status]=(tempMessage->size()-sizeof(Message))/_tarragonReceiveTypeSize;
                }
                tempListMessage = _tarragonReuseMessageList.find(TARRAGON_SYSTEM_BUFFER_SIZE);
                if (tempListMessage == _tarragonReuseMessageList.end()) 
                  _tarragonReuseMessageList.insert(pair<int, list<Message*>* > (TARRAGON_SYSTEM_BUFFER_SIZE, new list<Message*>));
                (_tarragonReuseMessageList[TARRAGON_SYSTEM_BUFFER_SIZE])->push_back(tempMessage);
              }
            }
            Bamboo_OpExec(recvbuf__12,((void *)tempbuf),count__13,datatype__14,op__15);
          }
        }
      }
      
#pragma bamboo send
      _tarragonIsFirstTimeRunning3 = 0;
      _tarragonIterationRollBack0 = mask;
      mask <<= 1;
      if (mask < _bambooCommSize) {
        if (!((mask & (((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize)) == 0)) {
          _tarragonMessageSize = count__13 * getsizeof(datatype__14);
          tempReuseMessageList = _tarragonReuseMessageList.find(TARRAGON_SYSTEM_BUFFER_SIZE);
          if (tempReuseMessageList != _tarragonReuseMessageList.end()) 
            if (!((*tempReuseMessageList).second)->empty()) {
              _tarragonMessage = ((*tempReuseMessageList).second)->front();
              ((*tempReuseMessageList).second)->pop_front();
              _tarragonMessage->set_size(_tarragonMessageSize+sizeof(Message));
            }
            else {
              if (_tarragonMessageSize > TARRAGON_SYSTEM_BUFFER_SIZE) {
                _attributes._state = T_ERROR;
                printf("Task %d is about to send a message that is larger than the system buffer -> Tarragon aborts all computation. Please increase the system buffer size, compile and run the code again.\n", _id);
                goto _tarragonExecuteExitOlap;
              }
              _tarragonMessage = make_message<BufferedMessage>(_tarragonMessageSize);
            }
          else {
            if (_tarragonMessageSize > TARRAGON_SYSTEM_BUFFER_SIZE) {
              _attributes._state = T_ERROR;
              printf("Task %d is about to send a message that is larger than the system buffer -> Tarragon aborts all computation. Please increase the system buffer size, compile and run the code again.\n", _id);
              goto _tarragonExecuteExitOlap;
            }
            _tarragonReuseMessageList.insert(pair<int, list<Message*>* > (TARRAGON_SYSTEM_BUFFER_SIZE, new list<Message*>));
            _tarragonMessage = make_message<BufferedMessage>(_tarragonMessageSize);
          }
{
            #if _OPENMP
;
            
#pragma omp parallel
{
              int numChunks = 1;
              if (_tarragonMessageSize % BAMBOO_COPY_CHUNKSIZE == 0) 
                numChunks = _tarragonMessageSize / BAMBOO_COPY_CHUNKSIZE;
              else 
                numChunks = _tarragonMessageSize / BAMBOO_COPY_CHUNKSIZE + 1;
              
#pragma omp for
              for (int _bambooChunkIter = 0; _bambooChunkIter < numChunks; ++_bambooChunkIter) 
                memcpy(((char *)_tarragonMessage->payload<void>()) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,((char *)recvbuf__12) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,_bambooChunkIter<(numChunks-1)?BAMBOO_COPY_CHUNKSIZE:(_tarragonMessageSize-(numChunks-1)*BAMBOO_COPY_CHUNKSIZE));
            }
            #else
;
            int _bambooPackPosition=0;
            Bamboo_Pack(recvbuf__12,count__13,datatype__14,_tarragonMessage->payload<void>(),_tarragonMessageSize,&_bambooPackPosition,MPI_COMM_WORLD);
            #endif
;
          }
          _tarragonMessage->set_src(_tarragonTaskId);
          *_tarragonMessage->key<int>() = 11100001;
          _tarragonMessageDestination = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) & ~mask) + root__16) % _bambooCommSize);
          _tarragonMessageDestination = comm__17== MPI_COMM_WORLD?_tarragonMessageDestination:_BAMBOOCommMap[comm__17][_tarragonMessageDestination+2];
          _tarragonNeighbor = dependency_out(_tarragonMessageDestination);
          _tarragonNeighbor->put(_tarragonMessage);
        }
      }
      if (mask < _bambooCommSize) {{
          if ((mask & (((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize)) == 0) {
            if (((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) < _bambooCommSize) {{
                _tarragonMessageSource = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) + root__16) % _bambooCommSize);
                _tarragonMessageSource = comm__17== MPI_COMM_WORLD?_tarragonMessageSource:_BAMBOOCommMap[comm__17][_tarragonMessageSource+2];
                tempMapMessage = _tarragonReceiveMessageMap.find(_tarragonMessageSource);
                if (tempMapMessage != _tarragonReceiveMessageMap.end()) {
                  tempListMessage = ((*tempMapMessage).second).find(11100001);
                  if (tempListMessage != ((*tempMapMessage).second).end()) 
                    if (((*tempListMessage).second)->empty()) {
                      _tarragon_fireable = false;
                    } else {}
                  else {
                    _tarragon_fireable = false;
                    _tarragonSourceKey = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) + root__16) % _bambooCommSize);
                    _tarragonTagKey = 11100001;
                    _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
                  }
                }
                else {
                  _tarragon_fireable = false;
                  _tarragonSourceKey = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) + root__16) % _bambooCommSize);
                  _tarragonTagKey = 11100001;
                  _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
                }
              }
            }
          }
        }
      }
    }
    else {
      _tarragon_loop_executing = 2;
      _tarragon_loop_initializing = false;
      isExitOlapRegion3= true;
    }
    _tarragonExecuteExitOlap:;
  }
  

  void injectOlapRegion3()
{
{
{
        if ((mask & (((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize)) == 0) {
          if (((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) < _bambooCommSize) {{
              _tarragonMessageSource = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) + root__16) % _bambooCommSize);
              _tarragonMessageSource = comm__17== MPI_COMM_WORLD?_tarragonMessageSource:_BAMBOOCommMap[comm__17][_tarragonMessageSource+2];
              tempMapMessage = _tarragonReceiveMessageMap.find(_tarragonMessageSource);
              if (tempMapMessage != _tarragonReceiveMessageMap.end()) {
                tempListMessage = ((*tempMapMessage).second).find(11100001);
                if (tempListMessage != ((*tempMapMessage).second).end()) 
                  if (((*tempListMessage).second)->empty()) {
                    _tarragon_fireable = false;
                  } else {}
                else {
                  _tarragon_fireable = false;
                  _tarragonSourceKey = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) + root__16) % _bambooCommSize);
                  _tarragonTagKey = 11100001;
                  _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
                }
              }
              else {
                _tarragon_fireable = false;
                _tarragonSourceKey = ((((((_bambooMyRank - root__16) + _bambooCommSize) % _bambooCommSize) | mask) + root__16) % _bambooCommSize);
                _tarragonTagKey = 11100001;
                _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
              }
            }
          }
        }
      }
    }
  }
  int mask;
}
;

class OlapClass0 : virtual public _BAMBOOGeneratedTask
{
  

  public: void initializeOlapRegion()
{
  }
  

  void executeOlapRegion()
{
  }
  

  void injectOlapRegion0()
{
  }
}
;

class OlapClass1 : public OlapClass0
{
  

  public: void initializeOlapRegion1()
{
    isExitOlapRegion1= false;
    _tarragonIsFirstTimeRunning1= 1;
    mask = 0x1;
    if (mask < _bambooCommSize) {
      if (!((mask & (((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize)) == 0)) {
        _tarragonMessageSize = count__4 * getsizeof(datatype__5);
        tempReuseMessageList = _tarragonReuseMessageList.find(TARRAGON_SYSTEM_BUFFER_SIZE);
        if (tempReuseMessageList != _tarragonReuseMessageList.end()) 
          if (!((*tempReuseMessageList).second)->empty()) {
            _tarragonMessage = ((*tempReuseMessageList).second)->front();
            ((*tempReuseMessageList).second)->pop_front();
            _tarragonMessage->set_size(_tarragonMessageSize+sizeof(Message));
          }
          else {
            if (_tarragonMessageSize > TARRAGON_SYSTEM_BUFFER_SIZE) {
              _attributes._state = T_ERROR;
              printf("Task %d is about to send a message that is larger than the system buffer -> Tarragon aborts all computation. Please increase the system buffer size, compile and run the code again.\n", _id);
              goto _tarragonExecuteExitOlap;
            }
            _tarragonMessage = make_message<BufferedMessage>(_tarragonMessageSize);
          }
        else {
          if (_tarragonMessageSize > TARRAGON_SYSTEM_BUFFER_SIZE) {
            _attributes._state = T_ERROR;
            printf("Task %d is about to send a message that is larger than the system buffer -> Tarragon aborts all computation. Please increase the system buffer size, compile and run the code again.\n", _id);
            goto _tarragonExecuteExitOlap;
          }
          _tarragonReuseMessageList.insert(pair<int, list<Message*>* > (TARRAGON_SYSTEM_BUFFER_SIZE, new list<Message*>));
          _tarragonMessage = make_message<BufferedMessage>(_tarragonMessageSize);
        }
{
          #if _OPENMP
;
          
#pragma omp parallel
{
            int numChunks = 1;
            if (_tarragonMessageSize % BAMBOO_COPY_CHUNKSIZE == 0) 
              numChunks = _tarragonMessageSize / BAMBOO_COPY_CHUNKSIZE;
            else 
              numChunks = _tarragonMessageSize / BAMBOO_COPY_CHUNKSIZE + 1;
            
#pragma omp for
            for (int _bambooChunkIter = 0; _bambooChunkIter < numChunks; ++_bambooChunkIter) 
              memcpy(((char *)_tarragonMessage->payload<void>()) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,((char *)recvbuf__3) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,_bambooChunkIter<(numChunks-1)?BAMBOO_COPY_CHUNKSIZE:(_tarragonMessageSize-(numChunks-1)*BAMBOO_COPY_CHUNKSIZE));
          }
          #else
;
          int _bambooPackPosition=0;
          Bamboo_Pack(recvbuf__3,count__4,datatype__5,_tarragonMessage->payload<void>(),_tarragonMessageSize,&_bambooPackPosition,MPI_COMM_WORLD);
          #endif
;
        }
        _tarragonMessage->set_src(_tarragonTaskId);
        *_tarragonMessage->key<int>() = 11100001;
        _tarragonMessageDestination = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) & ~mask) + root__7) % _bambooCommSize);
        _tarragonMessageDestination = comm__8== MPI_COMM_WORLD?_tarragonMessageDestination:_BAMBOOCommMap[comm__8][_tarragonMessageDestination+2];
        _tarragonNeighbor = dependency_out(_tarragonMessageDestination);
        _tarragonNeighbor->put(_tarragonMessage);
      }
    }
    if (mask < _bambooCommSize) {{
        if ((mask & (((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize)) == 0) {
          if (((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) < _bambooCommSize) {{
              _tarragonMessageSource = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) + root__7) % _bambooCommSize);
              _tarragonMessageSource = comm__8== MPI_COMM_WORLD?_tarragonMessageSource:_BAMBOOCommMap[comm__8][_tarragonMessageSource+2];
              tempMapMessage = _tarragonReceiveMessageMap.find(_tarragonMessageSource);
              if (tempMapMessage != _tarragonReceiveMessageMap.end()) {
                tempListMessage = ((*tempMapMessage).second).find(11100001);
                if (tempListMessage != ((*tempMapMessage).second).end()) 
                  if (((*tempListMessage).second)->empty()) {
                    _tarragon_fireable = false;
                  } else {}
                else {
                  _tarragon_fireable = false;
                  _tarragonSourceKey = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) + root__7) % _bambooCommSize);
                  _tarragonTagKey = 11100001;
                  _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
                }
              }
              else {
                _tarragon_fireable = false;
                _tarragonSourceKey = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) + root__7) % _bambooCommSize);
                _tarragonTagKey = 11100001;
                _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
              }
            }
          }
        }
      }
    }
    _tarragonExecuteExitOlap:;
  }
  bool isExitOlapRegion1;
  

  void executeOlapRegion1()
{
    if (mask < _bambooCommSize) {
      
#pragma bamboo receive
{
        if ((mask & (((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize)) == 0) {
          if (((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) < _bambooCommSize) {
            _tarragonMessageSource = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) + root__7) % _bambooCommSize);
            _tarragonMessageSource = comm__8== MPI_COMM_WORLD?_tarragonMessageSource:_BAMBOOCommMap[comm__8][_tarragonMessageSource+2];
{
              tempMapMessage = _tarragonReceiveMessageMap.find(_tarragonMessageSource);
              tempListMessage = ((*tempMapMessage).second).find(11100001);
{
                tempMessage = ((*tempListMessage).second)->front();
                ((*tempListMessage).second)->pop_front();
{
                  MPI_Type_size(datatype__5,&_tarragonReceiveTypeSize);
                  #if _OPENMP
;
                  
#pragma omp parallel
{
                    int _bambooReceiveMessageSize = tempMessage->size()-sizeof(Message);
                    int numChunks = 1;
                    if ((tempMessage->size()-sizeof(Message))/BAMBOO_COPY_CHUNKSIZE==0) 
                      numChunks= (tempMessage->size()-sizeof(Message))/BAMBOO_COPY_CHUNKSIZE;
                    else 
                      numChunks= (tempMessage->size()-sizeof(Message))/BAMBOO_COPY_CHUNKSIZE + 1;
                    
#pragma omp for
                    for (int _bambooChunkIter = 0; _bambooChunkIter < numChunks; ++_bambooChunkIter) 
                      memcpy(((char *)((void *)tempbuf)) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,((char *)tempMessage->payload<void>()) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,_bambooChunkIter<(numChunks-1)?BAMBOO_COPY_CHUNKSIZE:(_bambooReceiveMessageSize-(numChunks-1)*BAMBOO_COPY_CHUNKSIZE));
                  }
                  #else
;
                  int _bambooReceiveMessageSize = tempMessage->size()-sizeof(Message);
                  int _bambooUnpackPosition=0;
                  Bamboo_Unpack(tempMessage->payload<void>(),_bambooReceiveMessageSize,&_bambooUnpackPosition,((void *)tempbuf),_bambooReceiveMessageSize / _tarragonReceiveTypeSize,datatype__5,MPI_COMM_WORLD);
                  #endif
;
                  _BAMBOO_Status = ((MPI_Status *)((MPI_Status *)1));
                  _BAMBOO_MessageSizeMap[_BAMBOO_Status]=(tempMessage->size()-sizeof(Message))/_tarragonReceiveTypeSize;
                }
                tempListMessage = _tarragonReuseMessageList.find(TARRAGON_SYSTEM_BUFFER_SIZE);
                if (tempListMessage == _tarragonReuseMessageList.end()) 
                  _tarragonReuseMessageList.insert(pair<int, list<Message*>* > (TARRAGON_SYSTEM_BUFFER_SIZE, new list<Message*>));
                (_tarragonReuseMessageList[TARRAGON_SYSTEM_BUFFER_SIZE])->push_back(tempMessage);
              }
            }
            Bamboo_OpExec(recvbuf__3,((void *)tempbuf),count__4,datatype__5,op__6);
          }
        }
      }
      
#pragma bamboo send
      _tarragonIsFirstTimeRunning1 = 0;
      _tarragonIterationRollBack0 = mask;
      mask <<= 1;
      if (mask < _bambooCommSize) {
        if (!((mask & (((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize)) == 0)) {
          _tarragonMessageSize = count__4 * getsizeof(datatype__5);
          tempReuseMessageList = _tarragonReuseMessageList.find(TARRAGON_SYSTEM_BUFFER_SIZE);
          if (tempReuseMessageList != _tarragonReuseMessageList.end()) 
            if (!((*tempReuseMessageList).second)->empty()) {
              _tarragonMessage = ((*tempReuseMessageList).second)->front();
              ((*tempReuseMessageList).second)->pop_front();
              _tarragonMessage->set_size(_tarragonMessageSize+sizeof(Message));
            }
            else {
              if (_tarragonMessageSize > TARRAGON_SYSTEM_BUFFER_SIZE) {
                _attributes._state = T_ERROR;
                printf("Task %d is about to send a message that is larger than the system buffer -> Tarragon aborts all computation. Please increase the system buffer size, compile and run the code again.\n", _id);
                goto _tarragonExecuteExitOlap;
              }
              _tarragonMessage = make_message<BufferedMessage>(_tarragonMessageSize);
            }
          else {
            if (_tarragonMessageSize > TARRAGON_SYSTEM_BUFFER_SIZE) {
              _attributes._state = T_ERROR;
              printf("Task %d is about to send a message that is larger than the system buffer -> Tarragon aborts all computation. Please increase the system buffer size, compile and run the code again.\n", _id);
              goto _tarragonExecuteExitOlap;
            }
            _tarragonReuseMessageList.insert(pair<int, list<Message*>* > (TARRAGON_SYSTEM_BUFFER_SIZE, new list<Message*>));
            _tarragonMessage = make_message<BufferedMessage>(_tarragonMessageSize);
          }
{
            #if _OPENMP
;
            
#pragma omp parallel
{
              int numChunks = 1;
              if (_tarragonMessageSize % BAMBOO_COPY_CHUNKSIZE == 0) 
                numChunks = _tarragonMessageSize / BAMBOO_COPY_CHUNKSIZE;
              else 
                numChunks = _tarragonMessageSize / BAMBOO_COPY_CHUNKSIZE + 1;
              
#pragma omp for
              for (int _bambooChunkIter = 0; _bambooChunkIter < numChunks; ++_bambooChunkIter) 
                memcpy(((char *)_tarragonMessage->payload<void>()) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,((char *)recvbuf__3) + _bambooChunkIter * BAMBOO_COPY_CHUNKSIZE,_bambooChunkIter<(numChunks-1)?BAMBOO_COPY_CHUNKSIZE:(_tarragonMessageSize-(numChunks-1)*BAMBOO_COPY_CHUNKSIZE));
            }
            #else
;
            int _bambooPackPosition=0;
            Bamboo_Pack(recvbuf__3,count__4,datatype__5,_tarragonMessage->payload<void>(),_tarragonMessageSize,&_bambooPackPosition,MPI_COMM_WORLD);
            #endif
;
          }
          _tarragonMessage->set_src(_tarragonTaskId);
          *_tarragonMessage->key<int>() = 11100001;
          _tarragonMessageDestination = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) & ~mask) + root__7) % _bambooCommSize);
          _tarragonMessageDestination = comm__8== MPI_COMM_WORLD?_tarragonMessageDestination:_BAMBOOCommMap[comm__8][_tarragonMessageDestination+2];
          _tarragonNeighbor = dependency_out(_tarragonMessageDestination);
          _tarragonNeighbor->put(_tarragonMessage);
        }
      }
      if (mask < _bambooCommSize) {{
          if ((mask & (((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize)) == 0) {
            if (((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) < _bambooCommSize) {{
                _tarragonMessageSource = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) + root__7) % _bambooCommSize);
                _tarragonMessageSource = comm__8== MPI_COMM_WORLD?_tarragonMessageSource:_BAMBOOCommMap[comm__8][_tarragonMessageSource+2];
                tempMapMessage = _tarragonReceiveMessageMap.find(_tarragonMessageSource);
                if (tempMapMessage != _tarragonReceiveMessageMap.end()) {
                  tempListMessage = ((*tempMapMessage).second).find(11100001);
                  if (tempListMessage != ((*tempMapMessage).second).end()) 
                    if (((*tempListMessage).second)->empty()) {
                      _tarragon_fireable = false;
                    } else {}
                  else {
                    _tarragon_fireable = false;
                    _tarragonSourceKey = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) + root__7) % _bambooCommSize);
                    _tarragonTagKey = 11100001;
                    _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
                  }
                }
                else {
                  _tarragon_fireable = false;
                  _tarragonSourceKey = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) + root__7) % _bambooCommSize);
                  _tarragonTagKey = 11100001;
                  _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
                }
              }
            }
          }
        }
      }
    }
    else {
      _tarragon_loop_executing = 0;
      _tarragon_loop_initializing = false;
      isExitOlapRegion1= true;
    }
    _tarragonExecuteExitOlap:;
  }
  

  void injectOlapRegion1()
{
{
{
        if ((mask & (((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize)) == 0) {
          if (((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) < _bambooCommSize) {{
              _tarragonMessageSource = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) + root__7) % _bambooCommSize);
              _tarragonMessageSource = comm__8== MPI_COMM_WORLD?_tarragonMessageSource:_BAMBOOCommMap[comm__8][_tarragonMessageSource+2];
              tempMapMessage = _tarragonReceiveMessageMap.find(_tarragonMessageSource);
              if (tempMapMessage != _tarragonReceiveMessageMap.end()) {
                tempListMessage = ((*tempMapMessage).second).find(11100001);
                if (tempListMessage != ((*tempMapMessage).second).end()) 
                  if (((*tempListMessage).second)->empty()) {
                    _tarragon_fireable = false;
                  } else {}
                else {
                  _tarragon_fireable = false;
                  _tarragonSourceKey = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) + root__7) % _bambooCommSize);
                  _tarragonTagKey = 11100001;
                  _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
                }
              }
              else {
                _tarragon_fireable = false;
                _tarragonSourceKey = ((((((_bambooMyRank - root__7) + _bambooCommSize) % _bambooCommSize) | mask) + root__7) % _bambooCommSize);
                _tarragonTagKey = 11100001;
                _tarragonReceiveMessageMap[_tarragonSourceKey][_tarragonTagKey] =  new list<Message*>;
              }
            }
          }
        }
      }
    }
  }
  int mask;
}
;
unsigned int _BAMBOOGeneratedTask::_aggregation = 1U;
bool _BAMBOOGeneratedTask::_taffinity = 0;
bool _BAMBOOGeneratedTask::_tpriority = 0;
int _BAMBOOGeneratedTask::_tarragonP0 = 1;
int _BAMBOOGeneratedTask::_tarragonCommunicatorSize = 1;

class _BAMBOODummyClass : public OlapClass1,public OlapClass3
{
  

  public: void vinit()
{
    _tarragonCommHandle = -2080374784;
    _tarragonIsInitSend = 1;
    _tarragon_loop_executing = 0U;
    _tarragonNoOfReceives = 0U;
    _tarragon_fireable = 1;
    _tarragonIsMessageReceived = 0;
    _tarragon_loop_executing = 0U;
    _tarragon_loop_initializing = true;
    _tarragonIsFirstTimeRunning0 = 1;
    _tarragonIsFirstTimeRunning1 = 1;
    _tarragonIsFirstTimeRunning2 = 1;
    _tarragonIsFirstTimeRunning3 = 1;
    _tarragonTaskId = _id;
    if (_tarragon_fireable) {
      _attributes._state = T_EXEC;
    }
    else {
      _attributes._state = T_WAITING;
    }
    _tarragon_fireable = true;
  }
  

  void vexecute()
{
    if (_tarragon_loop_initializing) 
      switch(_tarragon_loop_executing){
        case 0 :goto _tarragonInitLoopStart;
        case 1 :goto _tarragonInitLoop1;
        case 2 :goto _tarragonInitLoop2;
        case 3 :goto _tarragonInitLoop3;
      }
    else 
      switch(_tarragon_loop_executing){
        case 0 :goto _tarragonLoop0;
        case 1 :goto _tarragonLoop1;
        case 2 :goto _tarragonLoop2;
        case 3 :goto _tarragonLoop3;
      }
    _tarragonInitLoopStart:
    float update(int myoffset,int chunk,int myid);
/***** Initializations *****/
    memcpy(&numtasks,&_tarragonCommunicatorSize,sizeof(int));
    if ((numtasks % 4) != 0) {
      printf("Quitting. Number of MPI tasks must be divisible by 4.\n");
      MPI_Abort(((MPI_Comm )0x44000000),rc);
      exit(0);
    }
    memcpy(&taskid,&_tarragonTaskId,sizeof(int));
    printf("MPI task %d has started...\n",taskid);
    chunksize = (16000000 / numtasks);
    tag2 = 1;
    tag1 = 2;
/***** Master task only ******/
    _tarragonInitLoop0:
    _tarragon_loop_initializing = false;
    _BambooLoopWrapperIterator0 = 0;
    _tarragonLoop0:
    if (_BambooLoopWrapperIterator0 < 1 && taskid == 0) {
/* Initialize the array */
      sum = 0;
      for (i = 0; i < 16000000; i++) {
        data[i] = (i * 1.0);
        sum = (sum + data[i]);
      }
      printf("Initialized array sum = %e\n",sum);
/* Send each task its portion of the array - master keeps 1st part */
      offset = chunksize;
      for (dest = 1; dest < numtasks; dest++) {
        MPI_Send((&offset),1,((MPI_Datatype )0x4c000405),dest,tag1,((MPI_Comm )0x44000000));
        MPI_Send((data + offset),chunksize,((MPI_Datatype )0x4c00040a),dest,tag2,((MPI_Comm )0x44000000));
        printf("Sent %d elements to task %d offset= %d\n",chunksize,dest,offset);
        offset = (offset + chunksize);
      }
/* Master does its part of the work */
      offset = 0;
      mysum = update(offset,chunksize,taskid);
/* Wait to receive results from each task */
      for (i = 1; i < numtasks; i++) {
        source = i;
        MPI_Recv((&offset),1,((MPI_Datatype )0x4c000405),source,tag1,((MPI_Comm )0x44000000),&status);
        MPI_Recv((data + offset),chunksize,((MPI_Datatype )0x4c00040a),source,tag2,((MPI_Comm )0x44000000),&status);
      }
{
        sendbuf__2 = ((void *)(&mysum));
        recvbuf__3 = ((void *)(&sum));
        count__4 = 1;
        datatype__5 = ((MPI_Datatype )0x4c00040a);
        op__6 = ((MPI_Op )0x58000003);
        root__7 = 0;
        comm__8 = ((MPI_Comm )0x44000000);
        if (comm__8 == MPI_COMM_WORLD) {
          memcpy(&_bambooMyRank,&_tarragonTaskId,sizeof(int));
        }
        else {
          memcpy(&_bambooMyRank,&_BAMBOOCommMap[comm__8][1],sizeof(int));
        }
        memcpy(&_bambooCommSize,comm__8== MPI_COMM_WORLD?&_tarragonCommunicatorSize:&_BAMBOOCommMap[comm__8][0],sizeof(int));
        tempbuf = ((char *)(malloc(((size_t )(count__4 * getsizeof(datatype__5))))));
        memcpy(((void *)tempbuf),sendbuf__2,((size_t )(count__4 * getsizeof(datatype__5))));
        
#pragma bamboo olap layout BinomialTreeConnector
        _tarragonInitLoop1:
        initializeOlapRegion1();
        _tarragon_loop_executing = 1;
        _tarragon_loop_initializing = false;
        goto _tarragonEvaluateState;
        _tarragonLoop1:
        executeOlapRegion1();
        if (isExitOlapRegion1== false) 
          goto _tarragonEvaluateState;
        free(((void *)tempbuf));
{
          0;
          goto rose_inline_end__9;
        }
        rose_inline_end__9:
        ;
      }
      printf("Sample results: \n");
      offset = 0;
      for (i = 0; i < numtasks; i++) {
        for (j = 0; j < 5; j++) 
          printf("  %e",data[offset + j]);
        printf("\n");
        offset = (offset + chunksize);
      }
      printf("*** Final sum= %e ***\n",sum);
      ++_BambooLoopWrapperIterator0;
      goto _tarragonEvaluateState;
/* end of master section */
    }
    else {
      _tarragon_loop_executing = 2;
      _tarragon_loop_initializing = true;
    }
/***** Non-master tasks only *****/
    _tarragonInitLoop2:
    _tarragon_loop_executing = 2;
    _tarragon_loop_initializing = false;
    _BambooLoopWrapperIterator1 = 0;
    _tarragonLoop2:
    if (_BambooLoopWrapperIterator1 < 1 && taskid > 0) {
/* Receive my portion of array from the master task */
      source = 0;
      MPI_Recv((&offset),1,((MPI_Datatype )0x4c000405),source,tag1,((MPI_Comm )0x44000000),&status);
      MPI_Recv((data + offset),chunksize,((MPI_Datatype )0x4c00040a),source,tag2,((MPI_Comm )0x44000000),&status);
      mysum = update(offset,chunksize,taskid);
/* Send my results back to the master task */
      dest = 0;
      MPI_Send((&offset),1,((MPI_Datatype )0x4c000405),dest,tag1,((MPI_Comm )0x44000000));
      MPI_Send((data + offset),chunksize,((MPI_Datatype )0x4c00040a),0,tag2,((MPI_Comm )0x44000000));
{
        sendbuf__11 = ((void *)(&mysum));
        recvbuf__12 = ((void *)(&sum));
        count__13 = 1;
        datatype__14 = ((MPI_Datatype )0x4c00040a);
        op__15 = ((MPI_Op )0x58000003);
        root__16 = 0;
        comm__17 = ((MPI_Comm )0x44000000);
        if (comm__17 == MPI_COMM_WORLD) {
          memcpy(&_bambooMyRank,&_tarragonTaskId,sizeof(int));
        }
        else {
          memcpy(&_bambooMyRank,&_BAMBOOCommMap[comm__17][1],sizeof(int));
        }
        memcpy(&_bambooCommSize,comm__17== MPI_COMM_WORLD?&_tarragonCommunicatorSize:&_BAMBOOCommMap[comm__17][0],sizeof(int));
        tempbuf = ((char *)(malloc(((size_t )(count__13 * getsizeof(datatype__14))))));
        memcpy(((void *)tempbuf),sendbuf__11,((size_t )(count__13 * getsizeof(datatype__14))));
        
#pragma bamboo olap layout BinomialTreeConnector
        _tarragonInitLoop3:
        initializeOlapRegion3();
        _tarragon_loop_executing = 3;
        _tarragon_loop_initializing = false;
        goto _tarragonEvaluateState;
        _tarragonLoop3:
        executeOlapRegion3();
        if (isExitOlapRegion3== false) 
          goto _tarragonEvaluateState;
        free(((void *)tempbuf));
{
          0;
          goto rose_inline_end__18;
        }
        rose_inline_end__18:
        ;
      }
      ++_BambooLoopWrapperIterator1;
      goto _tarragonEvaluateState;
/* end of non-master */
    }
    else {
      _tarragon_loop_executing = -1;
      _tarragon_loop_initializing = false;
    }
    _attributes._state = T_DONE;
    goto _tarragonExecuteExit;
    _tarragonEvaluateState:
    if (_tarragon_fireable) {
      _attributes._state = T_EXEC;
    }
    else {
      _attributes._state = T_WAITING;
    }
    _tarragon_fireable = true;
    _tarragonExecuteExit:;
/* end of main */
  }
  

  void vinject(Message *message)
{
    int sourceOfMessage = message->src();
    tempMapMessage = _tarragonReceiveMessageMap.find(sourceOfMessage);
    if (tempMapMessage == _tarragonReceiveMessageMap.end()) {
      _tarragonReceiveMessageMap[sourceOfMessage][*message->key<int>()] =  new list<Message*>;
    }
    else {
      tempListMessage = ((*tempMapMessage).second).find(*message->key<int>());
      if (tempListMessage == ((*tempMapMessage).second).end()) {
        _tarragonReceiveMessageMap[sourceOfMessage][*message->key<int>()] =  new list<Message*>;
      }
    }
    (_tarragonReceiveMessageMap[sourceOfMessage][*message->key<int>()])->push_back(message);
    switch(_tarragon_loop_executing){
      case 1 :goto _tarragonInjectLoop1;
      case 3 :goto _tarragonInjectLoop3;
    }
    _tarragonInjectLoop1:
    injectOlapRegion1();
    goto _tarragonFlipState;
    _tarragonInjectLoop3:
    injectOlapRegion3();
    goto _tarragonFlipState;
    _tarragonFlipState:
    if (_tarragon_fireable) {
      _attributes._state = T_EXEC;
    }
    _tarragon_fireable = true;
  }
  

  void _BAMBOOAssignCommunicator(MPI_Comm *handle,int* commData)
{
    *handle = _tarragonCommHandle++;
    _BAMBOOCommMap.insert(pair<MPI_Comm, int*> (*handle,  commData));
  }
  int _BambooLoopWrapperIterator0;
  int _BambooLoopWrapperIterator1;
}
;
int _BAMBOOGeneratedTask::argc;
char **_BAMBOOGeneratedTask::argv;

int main(int argc,char *argv[])
{
  _BAMBOOGeneratedTask::argc = argc;
  _BAMBOOGeneratedTask::argv = argv;
int _Tarragon_p0= 1;
Point<process_id,1> TarragonProcs(1);
int TarragonWorkers =1;
int _Tarragon_argCount = 0;
while(++_Tarragon_argCount <argc) {
   if(!strcmp(argv[_Tarragon_argCount], "-tarragonP0"))_Tarragon_p0 = TarragonProcs[0] = atoi(argv[++_Tarragon_argCount]);
   if(!strcmp(argv[_Tarragon_argCount], "-w"))TarragonWorkers = atoi(argv[++_Tarragon_argCount]);
}
_BAMBOOGeneratedTask::_tarragonP0 = _Tarragon_p0;
_BAMBOOGeneratedTask::_tarragonCommunicatorSize = _Tarragon_p0;
Tarragon::initialize(TarragonWorkers);
CartesianMap<1> _TarragonMap(TarragonProcs);
Graph* _BAMBOO_TarragonTaskGraphInstance = new VectorGraph<1,_BAMBOODummyClass> (&_TarragonMap);
BinomialTreeConnector< CartesianMap<1> > connectorNodeID1Layout0(_TarragonMap);
_BAMBOO_TarragonTaskGraphInstance->accept(connectorNodeID1Layout0);
BinomialTreeConnector< CartesianMap<1> > connectorNodeID3Layout0(_TarragonMap);
_BAMBOO_TarragonTaskGraphInstance->accept(connectorNodeID3Layout0);
Tarragon& tarragon_process = Tarragon::tarragon();
tarragon_process.graph_init(*_BAMBOO_TarragonTaskGraphInstance);
tarragon_process.graph_execute(*_BAMBOO_TarragonTaskGraphInstance);
double tarragon_initTime = tarragon_process.init_time();
if(tarragon_process.id() ==0) printf("Init time collected by Tarragon: %e  seconds \n ", tarragon_initTime);
double tarragon_execTime = tarragon_process.exec_time();
if(tarragon_process.id() ==0) printf("Exec time collected by Tarragon: %e  seconds\n ",tarragon_execTime);
delete _BAMBOO_TarragonTaskGraphInstance;
Tarragon::finalize();
//Stop instrumenting Tarragon
  //Code to construct a task graph;
}
/***** Initializations *****/

float update(int myoffset,int chunk,int myid)
{
  int i;
  float mysum;
/* Perform addition to each of my array elements and keep my sum */
  mysum = 0;
  for (i = myoffset; i < (myoffset + chunk); i++) {
    data[i] = (data[i] + (i * 1.0));
    mysum = (mysum + data[i]);
  }
  printf("Task %d mysum = %e\n",myid,mysum);
  return mysum;
}
